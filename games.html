<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Legon TV Game Hub</title>
    <link rel="icon" href="https://raw.githubusercontent.com/legontv/web-assets/main/logo.png" type="image/png">
    <meta name="description" content="Legon TV Game Hub - Play exciting 2D Chess, Football, and Racing games online.">
    <meta name="theme-color" content="#0d1b2a"> <style>
        :root {
            --deep-blue: #0d1b2a;
            --navy-blue: #1b263b;
            --blue: #3a86ff;
            --white: #f1f1f1;
            --glow: 0 0 15px rgba(58, 134, 255, 0.7);
            --button-glow: 0 0 15px rgba(0, 123, 255, 0.6);
            --button-hover-glow: 0 0 20px rgba(0, 123, 255, 0.9);
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(to bottom right, var(--deep-blue), var(--navy-blue));
            color: var(--white);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding-bottom: 2rem; /* Add padding to the bottom to prevent footer overlap */
        }

        header {
            width: 100%;
            padding: 1rem;
            background-color: var(--deep-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--glow);
            position: sticky;
            top: 0;
            z-index: 10;
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            box-sizing: border-box; /* Include padding in width */
        }

        header h1 {
            margin: 0;
            font-size: 1.8rem; /* Adjust font size for header */
             color: var(--white);
        }

        header nav {
            display: flex;
            align-items: center;
            margin-top: 0; /* Reset margin */
        }

        header nav a {
            margin: 0 15px;
            color: var(--white);
            text-decoration: none;
            font-weight: bold;
            font-size: 1rem; /* Adjust font size for nav links */
            transition: color 0.3s ease;
        }

        header nav a:hover {
            color: var(--blue);
        }

        main {
            flex-grow: 1; /* Allow main content to take up available space */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }


        .game-cards {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 2rem;
            padding: 2rem;
            width: 100%; /* Ensure game-cards takes full width */
            box-sizing: border-box; /* Include padding in width */
        }

        .card {
            background: var(--navy-blue);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: var(--glow);
            width: 250px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-sizing: border-box; /* Include padding in width */
        }

        .card h2 {
            color: var(--blue);
            margin-top: 0;
        }

        .card p {
            color: var(--white);
        }

        .card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--blue);
        }

        .game-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px; /* Max width for game container */
            padding: 0 1rem; /* Add horizontal padding */
            box-sizing: border-box; /* Include padding in width */
        }

        .game-container h2 {
             margin-top: 0; /* Remove margin top from game title */
             color: var(--blue);
        }


        canvas {
            width: 100%;
            max-width: 800px; /* Max width for canvas */
            height: 500px; /* Fixed height, adjust as needed */
            border-radius: 20px;
            background: #111; /* Dark background for canvas */
            box-shadow: var(--glow);
            margin: 1rem 0;
            display: block; /* Ensure canvas is a block element */
             touch-action: none; /* Prevent default touch actions */
        }

        .score {
            text-align: center;
            font-size: 1.3rem;
            margin-bottom: 1rem;
            font-weight: bold;
            color: var(--white);
            min-height: 1.3em; /* Reserve space to prevent layout shifts */
        }

         .game-info {
             text-align: center;
             color: var(--white);
             margin-bottom: 1rem;
         }


        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1rem 0; /* Adjust margin */
            flex-wrap: wrap; /* Allow buttons to wrap */
        }

        .controls button {
            background: var(--blue);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 12px;
            box-shadow: var(--button-glow);
            transition: transform 0.2s ease, box-shadow 0.3s ease, background-color 0.3s ease;
            cursor: pointer;
            font-weight: bold;
        }

        .controls button:hover {
            background-color: #265eff; /* Slightly darker blue on hover */
            transform: scale(1.05);
            box-shadow: var(--button-hover-glow);
        }

        footer {
            background: var(--deep-blue);
            padding: 2rem 1rem; /* Adjust padding */
            width: 100%;
            text-align: center;
            color: #ccc; /* Lighter text for copyright */
            box-shadow: var(--glow);
            margin-top: auto; /* Push footer to the bottom */
            box-sizing: border-box; /* Include padding in width */
        }

        footer h2 {
            margin-top: 0;
            color: var(--white); /* Ensure footer title is visible */
        }

        footer .socials a {
            margin: 0 1rem;
            color: var(--white);
            font-size: 2rem;
            text-decoration: none;
             transition: color 0.3s ease;
        }

         footer .socials a:hover {
             color: var(--blue);
         }

        /* Loading Spinner */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--deep-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s ease; /* Add fade out transition */
            opacity: 1;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }

        .loader {
            width: 70px;
            height: 70px;
            border: 10px solid var(--blue); /* Use blue color */
            border-top: 10px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0); }
            100% { transform: rotate(360deg); }
        }

        /* Mobile Responsive Adjustments */
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                align-items: flex-start;
            }

            header nav {
                 margin-top: 0.5rem;
                 justify-content: center; /* Center nav items */
                 width: 100%; /* Make nav take full width */
            }

            header nav a {
                margin: 0 10px; /* Reduce margin */
            }

            .game-cards {
                padding: 1rem; /* Reduce padding */
            }

            .card {
                width: 100%; /* Full width on mobile */
                max-width: 300px; /* Max width for cards */
            }

            canvas {
                height: 300px; /* Reduce height */
            }

            .controls {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem; /* Reduce gap */
            }

            .controls button {
                width: 80%;
                padding: 12px; /* Increase padding for easier tapping */
            }

             footer {
                padding: 1.5rem 1rem; /* Adjust footer padding */
            }

            footer .socials a {
                font-size: 1.5rem; /* Reduce icon size */
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
    </div>

    <header>
        <h1>Legon TV Game Hub</h1>
        <nav class="socials">
            <a href="https://www.tiktok.com/@legon.tvv" target="_blank" aria-label="TikTok"><i class="fa-brands fa-tiktok"></i></a>
            <a href="https://www.instagram.com/legontv.web" target="_blank" aria-label="Instagram"><i class="fa-brands fa-instagram"></i></a>
            <a href="https://www.youtube.com/@legontv" target="_blank" aria-label="YouTube"><i class="fa-brands fa-youtube"></i></a>
        </nav>
    </header>

    <main>
        <section class="game-cards" id="gameSelectionCards">
            <div class="card" data-game="chess">
                <h2>Chess</h2>
                <p>Play a classic game of Chess (2-player).</p>
            </div>
            <div class="card" data-game="football">
                <h2>Football Challenge</h2>
                <p>Kick the ball into the goal!</p>
            </div>
            <div class="card" data-game="racing">
                <h2>Car Racing</h2>
                <p>Dodge obstacles on the road!</p>
            </div>
        </section>

        <section id="currentGameContainer" class="game-container">
            <h2 id="gameTitle"></h2>
             <div class="game-info" id="gameInfo"></div> <canvas id="gameCanvas"></canvas>
            <div class="score" id="gameScoreDisplay"></div>
            <div class="controls">
                <button id="startGameBtn">Start</button>
                <button id="pauseGameBtn">Pause</button>
                <button id="resetGameBtn">Reset</button>
                <button id="exitGameBtn">Exit</button>
            </div>
        </section>
    </main>

    <footer>
        <h2>Follow Legon TV</h2>
        <div class="socials">
             <a href="https://www.tiktok.com/@legon.tvv" target="_blank" aria-label="TikTok"><i class="fa-brands fa-tiktok"></i></a>
            <a href="https://www.instagram.com/legontv.web" target="_blank" aria-label="Instagram"><i class="fa-brands fa-instagram"></i></a>
            <a href="https://www.youtube.com/@legontv" target="_blank" aria-label="YouTube"><i class="fa-brands fa-youtube"></i></a>
        </div>
        <p>© 2025 Legon TV Game Hub. All rights reserved.</p>
    </footer>

    <script src="https://kit.fontawesome.com/3e6e4c6a13.js" crossorigin="anonymous"></script>

    <script>
        // --- Game Classes ---

        // Chess Game (2D with Basic Move Validation)
        class ChessGame {
            constructor(canvasId, scoreDisplayId, infoDisplayId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext("2d");
                this.scoreDisplay = document.getElementById(scoreDisplayId); // Used for turn status
                this.infoDisplay = document.getElementById(infoDisplayId); // Used for messages
                this.tileSize = 60; // Will be adjusted based on canvas size
                this.boardSize = 8;
                this.board = []; // 2D array representing the board state
                this.selectedPiece = null; // Stores [x, y] of selected piece
                this.turn = "white"; // 'white' or 'black'
                this.isRunning = false;

                this.pieceSymbols = {
                    white: { pawn: "♙", rook: "♖", knight: "♘", bishop: "♗", queen: "♕", king: "♔" },
                    black: { pawn: "♟", rook: "♜", knight: "♞", bishop: "♝", queen: "♛", king: "♚" }
                };

                this.initBoard();
                // Initial draw will happen on start
            }

            initBoard() {
                // Create empty board
                this.board = new Array(this.boardSize).fill(null).map(() => new Array(this.boardSize).fill(null));
                // Place initial pieces
                const initialSetup = {
                    0: ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'], // Black
                    1: Array(8).fill('pawn'), // Black Pawns
                    6: Array(8).fill('pawn'), // White Pawns
                    7: ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'] // White
                };

                for (const row in initialSetup) {
                    const pieces = initialSetup[row];
                    const color = (row == 0 || row == 1) ? 'black' : 'white';
                    pieces.forEach((type, col) => {
                        this.board[row][col] = { color: color, type: type };
                    });
                }
            }

            getSymbol(piece) {
                 if (!piece) return '';
                 return this.pieceSymbols[piece.color][piece.type];
             }

            drawBoard() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

                // Adjust tileSize based on canvas size
                 this.tileSize = Math.min(canvas.width, canvas.height) / this.boardSize;
                 ctx.font = `${this.tileSize * 0.7}px Arial`;
                 ctx.textAlign = "center";
                 ctx.textBaseline = "middle";

                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        const isLight = (x + y) % 2 === 0;
                        ctx.fillStyle = isLight ? "#EEE" : "#888"; // Chessboard colors
                        ctx.fillRect(x * this.tileSize, y * this.tileSize, this.tileSize, this.tileSize);

                        const piece = this.board[y][x];
                        if (piece) {
                            this.drawPiece(x, y, piece);
                        }
                    }
                }

                 // Highlight selected square if any
                 if (this.selectedPiece) {
                     this.highlightSquare(this.selectedPiece[0], this.selectedPiece[1]);
                 }
            }

            drawPiece(x, y, piece) {
                const ctx = this.ctx;
                // Piece color is represented by the symbol, drawing color is for outline or highlight
                // For simplicity with text symbols, we rely on the symbol's look.
                // If we were drawing shapes, we'd use piece.color for fillStyle.
                const symbol = this.getSymbol(piece);
                ctx.fillText(symbol, x * this.tileSize + this.tileSize / 2, y * this.tileSize + this.tileSize / 2);
            }

             // --- Basic Move Validation (Simplified) ---
             // This is a simplified validator and does NOT check for check/checkmate,
             // pins, or advanced moves like castling or en passant.
             isValidMove(sx, sy, tx, ty) { // startX, startY, targetX, targetY
                 const piece = this.board[sy][sx];
                 const targetPiece = this.board[ty][tx];

                 if (!piece) return false; // No piece at start
                 if (targetPiece && targetPiece.color === piece.color) return false; // Cannot capture your own piece
                 if (sx === tx && sy === ty) return false; // Cannot move to the same square

                 const dx = Math.abs(tx - sx);
                 const dy = Math.abs(ty - sy);
                 const xDir = Math.sign(tx - sx);
                 const yDir = Math.sign(ty - sy);

                 switch (piece.type) {
                     case 'pawn':
                          // Pawns are tricky - direction depends on color
                          const forward = piece.color === 'white' ? -1 : 1;
                          const startRow = piece.color === 'white' ? 6 : 1;

                          // Forward move
                          if (dx === 0 && ty === sy + forward && !targetPiece) return true;

                          // Initial two-square move
                          if (dx === 0 && sy === startRow && ty === sy + 2 * forward && !targetPiece && !this.board[sy + forward][sx]) return true;

                          // Capture
                          if (dx === 1 && ty === sy + forward && targetPiece && targetPiece.color !== piece.color) return true;

                          return false; // Invalid pawn move

                     case 'rook':
                          if (dx !== 0 && dy !== 0) return false; // Must move horizontally or vertically
                          // Check for pieces in the way
                          if (dx > 0) { // Horizontal
                              for (let i = 1; i < dx; i++) { if (this.board[sy][sx + i * xDir]) return false; }
                          } else if (dy > 0) { // Vertical
                               for (let i = 1; i < dy; i++) { if (this.board[sy + i * yDir][sx]) return false; }
                          }
                          return true;

                     case 'knight':
                         return (dx === 1 && dy === 2) || (dx === 2 && dy === 1); // L-shape move

                     case 'bishop':
                         if (dx !== dy) return false; // Must move diagonally
                         // Check for pieces in the way
                         for (let i = 1; i < dx; i++) {
                             if (this.board[sy + i * yDir][sx + i * xDir]) return false;
                         }
                         return true;

                     case 'queen':
                         if (dx !== 0 && dy !== 0 && dx !== dy) return false; // Must move horizontally, vertically, or diagonally
                          // Check for pieces in the way (combine rook and bishop checks)
                           if (dx === 0) { // Vertical
                               for (let i = 1; i < dy; i++) { if (this.board[sy + i * yDir][sx]) return false; }
                           } else if (dy === 0) { // Horizontal
                                for (let i = 1; i < dx; i++) { if (this.board[sy][sx + i * xDir]) return false; }
                           } else if (dx === dy) { // Diagonal
                                for (let i = 1; i < dx; i++) { if (this.board[sy + i * yDir][sx + i * xDir]) return false; }
                           }
                           return true;

                     case 'king':
                         return dx <= 1 && dy <= 1; // Can move one square in any direction

                     default:
                         return false; // Unknown piece type
                 }
             }


            handleClick(e) {
                 if (!this.isRunning) return;

                const rect = this.canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Adjust click coordinates based on canvas size and position relative to window
                 const scaleX = this.canvas.width / rect.width;
                 const scaleY = this.canvas.height / rect.height;
                 const canvasX = clickX * scaleX;
                 const canvasY = clickY * scaleY;


                const x = Math.floor(canvasX / this.tileSize);
                const y = Math.floor(canvasY / this.tileSize);

                // Check if click is within board bounds
                 if (x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize) {
                     this.selectedPiece = null; // Deselect if clicking outside board
                     this.drawBoard();
                     return;
                 }

                const clicked = this.board[y][x];

                if (this.selectedPiece) {
                    const [sx, sy] = this.selectedPiece;

                    if (sx === x && sy === y) {
                        // Clicking on the same selected piece deselects it
                        this.selectedPiece = null;
                         this.infoDisplay.textContent = "Piece deselected.";
                    } else {
                        // Attempt to move the selected piece to the clicked square
                         if (this.isValidMove(sx, sy, x, y)) {
                              const pieceToMove = this.board[sy][sx];
                             // Execute the move
                             this.board[y][x] = pieceToMove;
                             this.board[sy][sx] = null;

                             // Switch turn
                             this.turn = this.turn === "white" ? "black" : "white";
                             this._updateStatus(); // Update status display
                              this.infoDisplay.textContent = "Valid move. Turn switched.";

                         } else {
                             // Invalid move
                             this.infoDisplay.textContent = "Invalid move.";
                         }
                        this.selectedPiece = null; // Clear selection after move attempt
                    }
                } else {
                    // No piece is selected, try to select the clicked piece
                    if (clicked && clicked.color === this.turn) {
                        this.selectedPiece = [x, y];
                         this.infoDisplay.textContent = `Selected ${clicked.color} ${clicked.type}.`;
                    } else if (clicked) {
                         this.infoDisplay.textContent = `It's ${this.turn}'s turn. Cannot select ${clicked.color} piece.`;
                    } else {
                         this.infoDisplay.textContent = "No piece selected.";
                    }
                }
                 this.drawBoard(); // Redraw board after any click
            }


            highlightSquare(x, y) {
                const ctx = this.ctx;
                ctx.strokeStyle = var(--blue); // Use blue for highlight
                ctx.lineWidth = 4;
                ctx.strokeRect(x * this.tileSize, y * this.tileSize, this.tileSize, this.tileSize);
            }

            _updateStatus() {
                 this.scoreDisplay.textContent = `${this.turn === "white" ? "White" : "Black"}'s Turn`;
            }

            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    this.initBoard(); // Reset board
                    this.turn = "white"; // Reset turn
                    this.selectedPiece = null;
                    this._updateStatus();
                     this.infoDisplay.textContent = "Game started. White's turn.";
                    this.drawBoard();
                     // Add event listener only when starting
                     this.canvas.addEventListener("click", this.handleClick.bind(this));
                }
            }

            pause() {
                if (this.isRunning) {
                    this.isRunning = false;
                     this.infoDisplay.textContent = "Game paused.";
                     // Optionally draw a pause overlay or change display
                }
            }

            reset() {
                 this.pause(); // Stop game loop/interaction
                 this.selectedPiece = null;
                 this.initBoard(); // Reset board to initial state
                 this.turn = "white"; // Reset turn
                 this._updateStatus(); // Update score display
                 this.infoDisplay.textContent = "Game reset. White's turn.";
                 this.drawBoard(); // Draw the reset board
                 // Remove and re-add listener to prevent multiple bindings on subsequent starts/resets
                 this.canvas.removeEventListener("click", this.handleClick.bind(this));
                 // Listener will be re-added on start()
            }

             // Method called when exiting the game
             exit() {
                 this.pause(); // Pause the game
                 // Clean up event listener
                 this.canvas.removeEventListener("click", this.handleClick.bind(this));
                 this.selectedPiece = null;
                 this.infoDisplay.textContent = ""; // Clear info message
                 this.scoreDisplay.textContent = ""; // Clear status
             }
        }

        // Football Game (2D with Paddles)
        class FootballGame {
            constructor(canvasId, scoreDisplayId, infoDisplayId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext("2d");
                this.scoreDisplay = document.getElementById(scoreDisplayId);
                this.infoDisplay = document.getElementById(infoDisplayId);
                this.width = this.canvas.width;
                this.height = this.canvas.height;

                this.ball = {};
                this.playerA = {}; // Left paddle
                this.playerB = {}; // Right paddle
                this.paddleWidth = 15;
                this.paddleHeight = 80;
                this.paddleSpeed = 6;

                this.goalWidth = 150;
                this.goalHeight = 20;
                this.goalA = {}; // Left Goal
                 this.goalB = {}; // Right Goal


                this.scores = { teamA: 0, teamB: 0 };
                this.isRunning = false;
                this.animationFrameId = null;

                 this.keys = {}; // For keyboard control (optional, but good to have)
                 this.setupKeyListeners(); // Setup keyboard listeners


                 // Touch/Mouse control variables
                 this.isDraggingA = false;
                 this.isDraggingB = false;
                 this.dragOffsetY = 0;

                 this.setupCanvasListeners(); // Setup mouse/touch listeners

                this.initGame(); // Setup initial positions
            }

            initGame() {
                 this.width = this.canvas.width; // Ensure width/height are updated if canvas size changes
                 this.height = this.canvas.height;

                this.ball = {
                    x: this.width / 2,
                    y: this.height / 2,
                    radius: 10,
                    vx: 5 * (Math.random() > 0.5 ? 1 : -1), // Random initial direction
                    vy: 5 * (Math.random() > 0.5 ? 1 : -1),
                };

                this.playerA = {
                    x: 20, // Left side
                    y: this.height / 2 - this.paddleHeight / 2,
                    width: this.paddleWidth,
                    height: this.paddleHeight,
                    score: 0
                };
                this.playerB = {
                    x: this.width - 20 - this.paddleWidth, // Right side
                    y: this.height / 2 - this.paddleHeight / 2,
                    width: this.paddleWidth,
                    height: this.paddleHeight,
                    score: 0
                };

                 this.goalA = { // Left Goal
                    x: 0,
                    y: this.height / 2 - this.goalWidth / 2, // Vertical goal
                    width: this.goalHeight, // Width is actually height for vertical
                    height: this.goalWidth, // Height is actually width for vertical
                 };
                 this.goalB = { // Right Goal
                     x: this.width - this.goalHeight,
                     y: this.height / 2 - this.goalWidth / 2, // Vertical goal
                     width: this.goalHeight,
                     height: this.goalWidth,
                 };


                this.scores = { teamA: 0, teamB: 0 };
                 this._updateScore();
                 this.infoDisplay.textContent = "Click/Touch canvas or use W/S, Up/Down to move paddles.";

                 this._draw(); // Draw initial state
            }

            resetBall() {
                 this.ball = {
                    x: this.width / 2,
                    y: this.height / 2,
                    radius: 10,
                    vx: 5 * (Math.random() > 0.5 ? 1 : -1),
                    vy: 5 * (Math.random() > 0.5 ? 1 : -1),
                };
            }

            _updateScore() {
                 this.scoreDisplay.textContent = `Score: ${this.scores.teamA} - ${this.scores.teamB}`;
            }

             setupKeyListeners() {
                 if (!this._keysListenersSetup) {
                     window.addEventListener("keydown", (e) => {
                         if (this.isRunning) this.keys[e.key] = true;
                     });
                     window.addEventListener("keyup", (e) => {
                          if (this.isRunning) this.keys[e.key] = false;
                     });
                     this._keysListenersSetup = true;
                 }
             }

             setupCanvasListeners() {
                 if (!this._canvasListenersSetup) {
                      // Mouse events
                     this.canvas.addEventListener("mousedown", this._handleMouseDown.bind(this));
                     this.canvas.addEventListener("mousemove", this._handleMouseMove.bind(this));
                     this.canvas.addEventListener("mouseup", this._handleMouseUp.bind(this));

                     // Touch events
                     this.canvas.addEventListener("touchstart", this._handleTouchStart.bind(this));
                     this.canvas.addEventListener("touchmove", this._handleTouchMove.bind(this));
                     this.canvas.addEventListener("touchend", this._handleTouchEnd.bind(this));
                     this._canvasListenersSetup = true;
                 }
             }

             _handleMouseDown(e) {
                  if (!this.isRunning) return;
                  const rect = this.canvas.getBoundingClientRect();
                  const clickY = e.clientY - rect.top;

                  // Check if click is on Player A's paddle
                  if (e.clientX - rect.left > this.playerA.x && e.clientX - rect.left < this.playerA.x + this.playerA.width &&
                      clickY > this.playerA.y && clickY < this.playerA.y + this.playerA.height) {
                      this.isDraggingA = true;
                      this.dragOffsetY = clickY - this.playerA.y;
                  }
                   // Check if click is on Player B's paddle
                   if (e.clientX - rect.left > this.playerB.x && e.clientX - rect.left < this.playerB.x + this.playerB.width &&
                       clickY > this.playerB.y && clickY < this.playerB.y + this.playerB.height) {
                       this.isDraggingB = true;
                       this.dragOffsetY = clickY - this.playerB.y;
                   }
             }

             _handleMouseMove(e) {
                 if (!this.isRunning) return;
                 const rect = this.canvas.getBoundingClientRect();
                 const mouseY = e.clientY - rect.top;

                 if (this.isDraggingA) {
                     let newY = mouseY - this.dragOffsetY;
                     // Clamp to canvas bounds
                     newY = Math.max(0, Math.min(this.height - this.playerA.height, newY));
                     this.playerA.y = newY;
                 }
                  if (this.isDraggingB) {
                     let newY = mouseY - this.dragOffsetY;
                     // Clamp to canvas bounds
                     newY = Math.max(0, Math.min(this.height - this.playerB.height, newY));
                     this.playerB.y = newY;
                 }
             }

             _handleMouseUp(e) {
                 this.isDraggingA = false;
                 this.isDraggingB = false;
             }

              _handleTouchStart(e) {
                  if (!this.isRunning) return;
                   // Prevent multiple touches from interfering
                  if (e.touches.length > 1) return;

                   const rect = this.canvas.getBoundingClientRect();
                   const touchY = e.touches[0].clientY - rect.top;
                   const touchX = e.touches[0].clientX - rect.left;


                   // Check if touch is near Player A's paddle
                   if (touchX > this.playerA.x - 20 && touchX < this.playerA.x + this.playerA.width + 20 && // Add some buffer
                       touchY > this.playerA.y - 20 && touchY < this.playerA.y + this.playerA.height + 20) {
                       this.isDraggingA = true;
                       this.dragOffsetY = touchY - this.playerA.y;
                        e.preventDefault(); // Prevent scrolling
                   }
                    // Check if touch is near Player B's paddle
                    if (touchX > this.playerB.x - 20 && touchX < this.playerB.x + this.playerB.width + 20 && // Add some buffer
                       touchY > this.playerB.y - 20 && touchY < this.playerB.y + this.playerB.height + 20) {
                       this.isDraggingB = true;
                       this.dragOffsetY = touchY - this.playerB.y;
                        e.preventDefault(); // Prevent scrolling
                    }
              }

              _handleTouchMove(e) {
                  if (!this.isRunning) return;
                   if (e.touches.length > 1) return;

                   const rect = this.canvas.getBoundingClientRect();
                   const touchY = e.touches[0].clientY - rect.top;

                   if (this.isDraggingA) {
                       let newY = touchY - this.dragOffsetY;
                       newY = Math.max(0, Math.min(this.height - this.playerA.height, newY));
                       this.playerA.y = newY;
                       e.preventDefault(); // Prevent scrolling
                   }
                    if (this.isDraggingB) {
                       let newY = touchY - this.dragOffsetY;
                       newY = Math.max(0, Math.min(this.height - this.playerB.height, newY));
                       this.playerB.y = newY;
                       e.preventDefault(); // Prevent scrolling
                   }
              }

              _handleTouchEnd(e) {
                  // Check if all touches are ended
                   if (e.touches.length === 0) {
                        this.isDraggingA = false;
                        this.isDraggingB = false;
                   }
              }


            _update() {
                // Move paddles with keyboard (optional alongside touch/mouse)
                 if (this.keys["w"] || this.keys["W"]) {
                     this.playerA.y -= this.paddleSpeed;
                 }
                 if (this.keys["s"] || this.keys["S"]) {
                     this.playerA.y += this.paddleSpeed;
                 }
                  if (this.keys["ArrowUp"]) {
                     this.playerB.y -= this.paddleSpeed;
                 }
                 if (this.keys["ArrowDown"]) {
                     this.playerB.y += this.paddleSpeed;
                 }

                 // Clamp paddle positions
                 this.playerA.y = Math.max(0, Math.min(this.height - this.playerA.height, this.playerA.y));
                 this.playerB.y = Math.max(0, Math.min(this.height - this.playerB.height, this.playerB.y));


                // Move ball
                this.ball.x += this.ball.vx;
                this.ball.y += this.ball.vy;

                // Bounce off top/bottom walls
                if (this.ball.y < this.ball.radius || this.ball.y > this.height - this.ball.radius) {
                    this.ball.vy *= -1;
                     // Prevent sticking
                     if (this.ball.y < this.ball.radius) this.ball.y = this.ball.radius;
                     if (this.ball.y > this.height - this.ball.radius) this.ball.y = this.height - this.ball.radius;
                }

                // Collision with paddles
                 const hitPlayerA = this.ball.x - this.ball.radius < this.playerA.x + this.playerA.width &&
                                    this.ball.y > this.playerA.y && this.ball.y < this.playerA.y + this.playerA.height;

                 const hitPlayerB = this.ball.x + this.ball.radius > this.playerB.x &&
                                    this.ball.y > this.playerB.y && this.ball.y < this.playerB.y + this.playerB.height;


                if (hitPlayerA) {
                     // Calculate bounce angle based on where the ball hit the paddle
                     const relativeIntersectY = (this.playerA.y + this.playerA.height / 2) - this.ball.y;
                     const normalizedRelativeIntersectionY = relativeIntersectY / (this.playerA.height / 2);
                     const bounceAngle = normalizedRelativeIntersectionY * (Math.PI / 4); // Max 45 degrees

                     this.ball.vx = 7 * Math.cos(bounceAngle); // Increase speed slightly
                     this.ball.vy = 7 * -Math.sin(bounceAngle);

                     // Prevent sticking
                     this.ball.x = this.playerA.x + this.playerA.width + this.ball.radius;

                } else if (hitPlayerB) {
                     const relativeIntersectY = (this.playerB.y + this.playerB.height / 2) - this.ball.y;
                     const normalizedRelativeIntersectionY = relativeIntersectY / (this.playerB.height / 2);
                     const bounceAngle = normalizedRelativeIntersectionY * (Math.PI / 4);

                     this.ball.vx = 7 * -Math.cos(bounceAngle); // Increase speed slightly and go left
                     this.ball.vy = 7 * -Math.sin(bounceAngle);

                      // Prevent sticking
                     this.ball.x = this.playerB.x - this.ball.radius;
                }


                // Goal detection (Left Goal - Team B scores)
                if (this.ball.x < this.goalA.x + this.goalA.width &&
                    this.ball.y > this.goalA.y && this.ball.y < this.goalA.y + this.goalA.height) {
                    this.scores.teamB++;
                    this._updateScore();
                    this.resetBall(); // Reset ball after goal
                     this.infoDisplay.textContent = "Goal for Team B!";
                }

                 // Goal detection (Right Goal - Team A scores)
                 if (this.ball.x > this.goalB.x &&
                     this.ball.y > this.goalB.y && this.ball.y < this.goalB.y + this.goalB.height) {
                     this.scores.teamA++;
                     this._updateScore();
                     this.resetBall(); // Reset ball after goal
                      this.infoDisplay.textContent = "Goal for Team A!";
                 }

                 // Check for game over (e.g., first to 10)
                 if (this.scores.teamA >= 10) {
                     this.pause();
                     this._updateScore("Team A Wins!");
                     this.infoDisplay.textContent = "Game Over!";
                 } else if (this.scores.teamB >= 10) {
                     this.pause();
                     this._updateScore("Team B Wins!");
                     this.infoDisplay.textContent = "Game Over!";
                 }
            }

            _drawField() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height); // Clear canvas
                ctx.fillStyle = "#1a6b3a"; // Darker green field
                ctx.fillRect(0, 0, this.width, this.height);

                // Draw center line
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(this.width / 2, this.height);
                ctx.stroke();

                // Draw center circle
                ctx.beginPath();
                ctx.arc(this.width / 2, this.height / 2, 60, 0, Math.PI * 2);
                ctx.stroke();

                 // Draw Goals
                 ctx.fillStyle = "white";
                 ctx.fillRect(this.goalA.x, this.goalA.y, this.goalA.width, this.goalA.height); // Left goal
                 ctx.fillRect(this.goalB.x, this.goalB.y, this.goalB.width, this.goalB.height); // Right goal
            }

            _drawPaddles() {
                const ctx = this.ctx;
                ctx.fillStyle = var(--blue); // Blue paddles
                ctx.fillRect(this.playerA.x, this.playerA.y, this.playerA.width, this.playerA.height);
                ctx.fillRect(this.playerB.x, this.playerB.y, this.playerB.width, this.playerB.height);
            }

            _drawBall() {
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = var(--white); // White ball
                ctx.fill();
                ctx.stroke();
            }

            _draw() {
                this._drawField();
                this._drawPaddles();
                this._drawBall();
            }

            _loop = () => {
                if (!this.isRunning) return;
                this._update();
                this._draw();
                this.animationFrameId = requestAnimationFrame(this._loop);
            };

            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    this.initGame(); // Reset game state
                    this._loop(); // Start the animation loop
                    this.infoDisplay.textContent = "Game started!";
                }
            }

            pause() {
                if (this.isRunning) {
                    this.isRunning = false;
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId); // Stop animation loop
                        this.animationFrameId = null;
                    }
                     this.infoDisplay.textContent = "Game paused.";
                }
            }

            reset() {
                this.pause(); // Stop the game loop
                this.initGame(); // Reset game state
                this._updateScore(); // Reset score display
                this._draw(); // Draw the initial state
                 this.infoDisplay.textContent = "Game reset. Click Start to play.";
            }

             exit() {
                 this.pause();
                  // Clean up event listeners if necessary (though in this case, they are general window/canvas listeners handled by manager)
                  this.infoDisplay.textContent = "";
                  this.scoreDisplay.textContent = "";
             }
        }


        // Racing Game (2D with Increasing Difficulty)
        class RacingGame {
             constructor(canvasId, scoreId, infoDisplayId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext("2d");
                this.scoreDisplay = document.getElementById(scoreId);
                 this.infoDisplay = document.getElementById(infoDisplayId);
                this.width = this.canvas.width;
                this.height = this.canvas.height;

                this.car = {};
                this.obstacles = [];
                this.keys = {};
                this.score = 0;
                this.isRunning = false;
                this.animationFrameId = null;
                this.obstacleInterval = null;

                 this.obstacleSpeed = 4; // Initial obstacle speed
                 this.speedIncreaseRate = 0.001; // How much speed increases per frame

                 this.setupKeyListeners(); // Setup keyboard listeners

                this.initGame();
            }

             initGame() {
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.car = { x: this.width / 2 - 25, y: this.height - 100, width: 50, height: 80, speed: 7 }; // Center the car
                this.obstacles = [];
                this.score = 0;
                this.obstacleSpeed = 4; // Reset speed
                this._updateScore();
                 this.infoDisplay.textContent = "Use Left/Right Arrows or A/D to steer.";

                 this._draw(); // Initial draw
             }

            setupKeyListeners() {
                if (!this._keysListenersSetup) {
                     window.addEventListener("keydown", (e) => {
                       if(this.isRunning) this.keys[e.key] = true;
                     });
                     window.addEventListener("keyup", (e) => {
                       if(this.isRunning) this.keys[e.key] = false;
                     });
                     this._keysListenersSetup = true;
                }
            }

            spawnObstacle() {
                 const roadWidth = 300;
                 const roadLeft = this.width / 2 - roadWidth / 2;
                 const laneOffset = 80; // Distance from center line
                 const obstacleWidth = 50;
                 const obstacleHeight = 80;

                 const laneX = [
                    roadLeft + roadWidth / 4 - obstacleWidth / 2, // Left lane
                    this.width / 2 - obstacleWidth / 2,             // Center lane
                    roadLeft + roadWidth * 3 / 4 - obstacleWidth / 2 // Right lane
                 ];

                 const randomX = laneX[Math.floor(Math.random() * laneX.length)];
                 this.obstacles.push({ x: randomX, y: -obstacleHeight, width: obstacleWidth, height: obstacleHeight });
            }

            moveCar() {
                 const roadWidth = 300;
                 const roadLeftBoundary = this.width / 2 - roadWidth / 2;
                 const roadRightBoundary = this.width / 2 + roadWidth / 2 - this.car.width;


                if (this.keys["ArrowLeft"] || this.keys["a"]) {
                    this.car.x -= this.car.speed;
                    if (this.car.x < roadLeftBoundary) this.car.x = roadLeftBoundary;
                }
                if (this.keys["ArrowRight"] || this.keys["d"]) {
                    this.car.x += this.car.speed;
                    if (this.car.x > roadRightBoundary) this.car.x = roadRightBoundary;
                }
            }

            updateObstacles() {
                for (let i = this.obstacles.length - 1; i >= 0; i--) { // Iterate backwards for safe removal
                    this.obstacles[i].y += this.obstacleSpeed; // Use increasing speed

                    // Collision detection
                    if (
                        this.car.x < this.obstacles[i].x + this.obstacles[i].width &&
                        this.car.x + this.car.width > this.obstacles[i].x &&
                        this.car.y < this.obstacles[i].y + this.obstacles[i].height &&
                        this.car.y + this.car.height > this.obstacles[i].y
                    ) {
                        this.pause(); // Stop game on collision
                        this._updateScore("Game Over! Score: " + this.score); // Update score display
                         this.infoDisplay.textContent = "Crashed! Click Reset.";
                        return; // Exit update loop after game over
                    }

                    // Remove obstacles off screen and update score
                    if (this.obstacles[i].y > this.height) {
                        this.obstacles.splice(i, 1);
                        this.score++;
                        this._updateScore();
                    }
                }
                 // Increase obstacle speed gradually
                 this.obstacleSpeed += this.speedIncreaseRate;
            }

            _updateScore(message = "Score: " + this.score) {
                 this.scoreDisplay.textContent = message;
            }


            drawRoad() {
                const ctx = this.ctx;
                const roadWidth = 300; // Define road width
                const roadLeft = this.width / 2 - roadWidth / 2;

                ctx.fillStyle = "#444"; // Darker gray road color
                ctx.fillRect(roadLeft, 0, roadWidth, this.height);

                // Lane lines
                ctx.fillStyle = "white";
                const laneLineDashLength = 30;
                const laneLineGap = 20;
                const laneLineInterval = laneLineDashLength + laneLineGap;
                // Adjust line drawing for continuous scrolling effect (more advanced)
                // For simplicity here, we draw static lines.
                // To make lines move, you'd need an offset that changes over time.

                const lanePositions = [
                    roadLeft + roadWidth / 4, // Left lane line
                    this.width / 2,             // Center line
                    roadLeft + roadWidth * 3 / 4 // Right lane line
                ];

                ctx.setLineDash([laneLineDashLength, laneLineGap]);
                 ctx.lineWidth = 4;

                lanePositions.forEach(pos => {
                    ctx.beginPath();
                    ctx.moveTo(pos, 0);
                    ctx.lineTo(pos, this.height);
                    ctx.stroke();
                });

                ctx.setLineDash([]); // Reset dash
                 ctx.lineWidth = 1; // Reset line width
            }

            drawCar() {
                this.ctx.fillStyle = var(--blue); // Blue car
                this.ctx.fillRect(this.car.x, this.car.y, this.car.width, this.car.height);
                 // Add some simple details for realism
                 this.ctx.fillStyle = var(--navy-blue); // Darker blue for details
                 this.ctx.fillRect(this.car.x + 5, this.car.y + 10, this.car.width - 10, 15); // Window
                 this.ctx.fillRect(this.car.x + 5, this.car.y + this.car.height - 25, this.car.width - 10, 15); // Rear window/spoiler
            }

            drawObstacles() {
                this.ctx.fillStyle = "red"; // Obstacle color
                for (let obs of this.obstacles) {
                    this.ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                }
            }

            _draw() {
                 this.ctx.clearRect(0, 0, this.width, this.height); // Clear canvas
                this.drawRoad();
                this.drawCar();
                this.drawObstacles();
            }

            _loop = () => {
                if (!this.isRunning) return; // Stop loop if not running

                this.moveCar();
                this.updateObstacles(); // Update obstacles and check collision/score
                this._draw();

                this.animationFrameId = requestAnimationFrame(this._loop);
            };

            start() {
                 if (!this.isRunning) {
                     this.isRunning = true;
                     this.initGame(); // Setup initial game state
                     this._updateScore(); // Display initial score
                     this.listenKeys(); // Ensure key listeners are active
                     this._draw(); // Initial draw
                     this._loop(); // Start game loop

                     // Start spawning obstacles
                     this.obstacleInterval = setInterval(() => {
                       if (this.isRunning) this.spawnObstacle();
                     }, 2000); // Spawn obstacle every 2 seconds
                      this.infoDisplay.textContent = "Race started! Avoid obstacles.";
                 }
            }

            pause() {
                if (this.isRunning) {
                    this.isRunning = false;
                     if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId); // Stop animation loop
                        this.animationFrameId = null;
                     }
                     if (this.obstacleInterval) {
                        clearInterval(this.obstacleInterval); // Stop obstacle spawning
                        this.obstacleInterval = null;
                     }
                     this.infoDisplay.textContent = "Game paused.";
                }
            }

            reset() {
                 this.pause(); // Stop game loop and intervals
                 this.initGame(); // Reset game state (incl. speed, score, obstacles, car pos)
                 this._updateScore("Score: 0"); // Reset score display
                 this._draw(); // Draw reset state
                 this.infoDisplay.textContent = "Game reset. Click Start to play.";
            }

             exit() {
                 this.pause();
                 this.infoDisplay.textContent = "";
                 this.scoreDisplay.textContent = "";
             }
        }


        // --- Main Game Manager ---
        document.addEventListener("DOMContentLoaded", () => {
            const gameSelectionCards = document.getElementById("gameSelectionCards");
            const currentGameContainer = document.getElementById("currentGameContainer");
            const gameTitleElement = document.getElementById("gameTitle");
            const gameCanvasElement = document.getElementById("gameCanvas");
            const gameScoreDisplayElement = document.getElementById("gameScoreDisplay");
            const gameInfoDisplayElement = document.getElementById("gameInfo"); // Get info display
            const loadingScreen = document.getElementById("loading");

            const startGameBtn = document.getElementById("startGameBtn");
            const pauseGameBtn = document.getElementById("pauseGameBtn");
            const resetGameBtn = document.getElementById("resetGameBtn");
            const exitGameBtn = document.getElementById("exitGameBtn");

            let activeGame = null; // To hold the instance of the currently active game
            let currentGameType = null; // To remember which game is active

            // Hide loading screen after DOM is fully loaded
            loadingScreen.classList.add("hidden");
            loadingScreen.addEventListener('transitionend', () => {
                loadingScreen.style.display = 'none';
            }, { once: true }); // Remove display after transition


            // Event listeners for game selection cards
            gameSelectionCards.querySelectorAll(".card").forEach(card => {
                card.addEventListener("click", () => {
                    const gameType = card.dataset.game;
                    showGame(gameType);
                });
            });

            // Event listeners for game control buttons
            startGameBtn.addEventListener("click", () => {
                if (activeGame && typeof activeGame.start === 'function') {
                    activeGame.start();
                     // Disable Start button, enable Pause/Reset
                     startGameBtn.disabled = true;
                     pauseGameBtn.disabled = false;
                     resetGameBtn.disabled = false;
                }
            });

            pauseGameBtn.addEventListener("click", () => {
                 if (activeGame && typeof activeGame.pause === 'function') {
                    activeGame.pause();
                     // Enable Start button, Keep Reset enabled
                     startGameBtn.disabled = false;
                     // pauseGameBtn remains enabled
                     resetGameBtn.disabled = false;
                }
            });

            resetGameBtn.addEventListener("click", () => {
                 if (activeGame && typeof activeGame.reset === 'function') {
                    activeGame.reset();
                     // Enable Start button, Disable Pause, Enable Reset
                     startGameBtn.disabled = false;
                     pauseGameBtn.disabled = true; // Pause doesn't make sense immediately after reset
                     resetGameBtn.disabled = false;
                }
            });

            exitGameBtn.addEventListener("click", () => {
                 if (activeGame && typeof activeGame.exit === 'function') {
                    activeGame.exit();
                 }
                 activeGame = null; // Clear the game instance
                 currentGameType = null; // Clear the game type
                 hideGame(); // Hide the game container and show cards
                 // Reset button states
                 startGameBtn.disabled = false;
                 pauseGameBtn.disabled = true;
                 resetGameBtn.disabled = false; // Reset still makes sense on card screen
            });

            // Function to show the selected game
            function showGame(gameType) {
                // Before showing a new game, exit the previous one if active
                 if (activeGame && typeof activeGame.exit === 'function') {
                     activeGame.exit();
                 }
                 activeGame = null; // Clear the reference

                // Set canvas size (adjust as needed, ensures consistency)
                 // Note: Actual canvas drawing size might be affected by CSS,
                 // but setting attributes is important for drawing resolution.
                 const canvasWidth = currentGameContainer.clientWidth > 900 ? 800 : Math.min(800, currentGameContainer.clientWidth - 30); // Max 800, or container width - padding
                 const canvasHeight = canvasWidth * (500 / 800); // Maintain aspect ratio based on 800x500 original size
                 gameCanvasElement.width = canvasWidth;
                 gameCanvasElement.height = canvasHeight;


                // Instantiate the selected game
                switch (gameType) {
                    case "chess":
                        gameTitleElement.textContent = "Chess";
                         gameInfoDisplayElement.textContent = "Click on a piece to select, then click on a square to move. White moves first.";
                        activeGame = new ChessGame("gameCanvas", "gameScoreDisplay", "gameInfo");
                        break;
                    case "football":
                        gameTitleElement.textContent = "Football Challenge";
                         gameInfoDisplayElement.textContent = "Click/Touch the canvas to move your paddles vertically (Left = Player A, Right = Player B) or use W/S and Up/Down arrows.";
                        activeGame = new FootballGame("gameCanvas", "gameScoreDisplay", "gameInfo");
                        break;
                    case "racing":
                        gameTitleElement.textContent = "Car Racing";
                         gameInfoDisplayElement.textContent = "Use Left/Right Arrow keys or A/D to steer the car. Avoid obstacles. Score is distance.";
                        activeGame = new RacingGame("gameCanvas", "gameScoreDisplay", "gameInfo");
                        break;
                    default:
                        console.error("Unknown game type:", gameType);
                        return; // Exit if game type is invalid
                }

                currentGameType = gameType; // Store the active game type

                // Initial state for controls when game container is shown
                startGameBtn.disabled = false;
                pauseGameBtn.disabled = true;
                resetGameBtn.disabled = false;

                 // Initial draw/setup for the specific game
                 if (activeGame && typeof activeGame.initGame === 'function') {
                     activeGame.initGame(); // Call initGame for setup/reset
                 } else if (activeGame && typeof activeGame.reset === 'function') {
                      // Fallback to reset if initGame doesn't exist (Chess)
                      activeGame.reset(); // Reset also draws initial state for Chess
                 }


                // Hide game selection cards and show the game container
                gameSelectionCards.style.display = "none";
                currentGameContainer.style.display = "flex"; // Use flex for centering content
            }

            // Function to hide the current game and show game selection
            function hideGame() {
                currentGameContainer.style.display = "none";
                gameSelectionCards.style.display = "flex"; // Use flex for centering cards

                 // Clear canvas when hiding
                 const ctx = gameCanvasElement.getContext('2d');
                 ctx.clearRect(0, 0, gameCanvasElement.width, gameCanvasElement.height);

                 // Reset displays
                 gameScoreDisplayElement.textContent = "";
                 gameTitleElement.textContent = ""; // Clear title
                 gameInfoDisplayElement.textContent = ""; // Clear info
            }

            // Initial state: Only show game selection cards
            hideGame(); // Call hideGame initially to set up the view

        });

    </script>
</body>
</html>
