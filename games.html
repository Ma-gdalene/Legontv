<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Legon TV Game Hub</title>

<!-- Fonts & icons -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet" />

<!-- Three.js for 3D rendering -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>

<style>
  /* --- Reset and base --- */
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body {
    font-family: 'Montserrat', sans-serif;
    background: linear-gradient(135deg, #0a3d62, #3c6382);
    color: #e1e5ea;
    min-height: 100vh;
    display: flex; flex-direction: column;
  }

  /* --- Header & Nav --- */
  .utility-bar {
    background: #162f4d;
    color: #a3b1c6;
    padding: 0.3em 1em;
    font-size: 0.9rem;
    display: flex; justify-content: space-between; align-items: center;
  }
  .breaking-news {
    font-weight: 600;
    color: #f9ca24;
  }
  .sign-in {
    color: #f9ca24;
    text-decoration: none;
    font-weight: 700;
    cursor: pointer;
  }
  .sign-in:hover {
    text-decoration: underline;
  }

  header.navbar {
    background: #1e4f75;
    display: flex;
    align-items: center;
    padding: 0.8em 1em;
    box-shadow: 0 0 15px rgba(0,0,0,0.7);
    position: sticky;
    top: 0;
    z-index: 999;
  }
  .logo {
    height: 50px;
    margin-right: 20px;
  }
  nav.nav-links a {
    color: #cfd8dc;
    margin: 0 15px;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.05rem;
    transition: color 0.3s;
  }
  nav.nav-links a:hover,
  nav.nav-links a.active {
    color: #f9ca24;
    text-shadow: 0 0 8px #f9ca24;
  }

  /* --- Main content --- */
  main {
    flex: 1;
    padding: 1.5rem;
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
  }
  h1.main-title {
    font-size: 2.8rem;
    margin-bottom: 1rem;
    text-align: center;
    color: #f9ca24;
    text-shadow: 0 0 10px #f9ca24;
  }
  p.motivation {
    text-align: center;
    font-size: 1.2rem;
    margin-bottom: 2rem;
    color: #d3dfe6;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
  }

  /* --- Game cards --- */
  .game-cards {
    display: flex;
    justify-content: center;
    gap: 30px;
    flex-wrap: wrap;
    margin-bottom: 2rem;
  }
  .game-card {
    background: linear-gradient(145deg, #2e86de, #054a91);
    width: 280px;
    height: 180px;
    border-radius: 20px;
    box-shadow: 0 0 20px #3a7bd5;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: #f9ca24;
    font-size: 1.5rem;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  .game-card:hover {
    transform: scale(1.05);
    box-shadow: 0 0 30px #f9ca24;
  }
  .game-card:active {
    transform: scale(0.95);
  }
  .game-card svg {
    width: 60px;
    height: 60px;
    margin-bottom: 15px;
    filter: drop-shadow(0 0 5px #f9ca24);
  }

  /* --- Game container --- */
  .game-container {
    background: #183661;
    border-radius: 20px;
    box-shadow: 0 0 40px #3a7bd5;
    padding: 1rem;
    max-width: 900px;
    margin: 0 auto 3rem;
    display: none;
    flex-direction: column;
    align-items: center;
  }
  .game-container.active {
    display: flex;
  }
  .game-title {
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: 1rem;
    color: #f9ca24;
    text-shadow: 0 0 8px #f9ca24;
  }

  /* --- Canvas styles for 3D games --- */
  canvas {
    border-radius: 15px;
    box-shadow: 0 0 25px #f9ca24;
    background: #0a2a5a;
    max-width: 100%;
    height: 480px;
  }

  /* --- Controls panel --- */
  .controls {
    margin-top: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
  }
  .btn-control {
    background: #f9ca24;
    border: none;
    padding: 12px 20px;
    border-radius: 15px;
    color: #183661;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    box-shadow: 0 0 10px #f9ca24;
    transition: background 0.3s ease;
    user-select: none;
    min-width: 100px;
    text-align: center;
  }
  .btn-control:hover {
    background: #fbcf4a;
  }
  .btn-control:active {
    background: #d4af37;
  }

  /* --- Scoreboard --- */
  .scoreboard {
    margin-top: 1rem;
    font-size: 1.2rem;
    font-weight: 600;
    color: #f9ca24;
    text-shadow: 0 0 6px #f9ca24;
  }

  /* --- Footer --- */
  footer {
    background: #1e4f75;
    padding: 1rem 1.5rem;
    text-align: center;
    color: #cfd8dc;
    box-shadow: 0 -5px 10px rgba(0,0,0,0.4);
    user-select: none;
  }
  footer .footer-links {
    margin-top: 0.5rem;
  }
  footer .footer-links a {
    color: #f9ca24;
    margin: 0 10px;
    text-decoration: none;
    font-weight: 600;
    transition: color 0.3s ease;
  }
  footer .footer-links a:hover {
    color: #fbcf4a;
  }

  /* --- Responsive --- */
  @media (max-width: 900px) {
    .game-cards {
      flex-direction: column;
      align-items: center;
    }
  }
  @media (max-width: 400px) {
    .btn-control {
      min-width: 80px;
      padding: 10px 14px;
      font-size: 0.9rem;
    }
  }
</style>

</head>
<body>

<!-- Utility Bar -->
<div class="utility-bar">
  <span class="breaking-news">Breaking: Legon TV launches its brand-new digital platform!</span>
  <a href="#" class="sign-in">Sign In</a>
</div>

<!-- Navigation -->
<header class="navbar">
  <img src="https://i.imgur.com/IqL1PbX.png" alt="Legon TV Logo" class="logo" />
  <nav class="nav-links" aria-label="Primary Navigation">
    <a href="index.html">Home</a>
    <a href="news.html">News</a>
    <a href="politics.html">Politics</a>
    <a href="shop.html">Shop</a>
    <a href="entertainment.html">Entertainment</a>
    <a href="games.html" class="active">Games</a>
  </nav>
</header>

<main>
  <h1 class="main-title">Legon TV Game Hub</h1>
  <p class="motivation">Play premium 3D games with immersive controls, realistic physics, and smart AI. Compatible with all devices: PC, tablets, and phones.</p>

  <section class="game-cards">
    <div class="game-card" id="card-chess" tabindex="0" role="button" aria-pressed="false" aria-label="Play 3D Chess Game">
      <svg viewBox="0 0 64 64" fill="none" stroke="#f9ca24" stroke-width="4" stroke-linejoin="round" stroke-linecap="round">
        <path d="M16 48h32l-8-32H24l-8 32z"/>
        <path d="M32 24v24"/>
        <path d="M24 40h16"/>
      </svg>
      3D Chess
    </div>
    <div class="game-card" id="card-football" tabindex="0" role="button" aria-pressed="false" aria-label="Play Football Challenge">
      <svg viewBox="0 0 64 64" fill="none" stroke="#f9ca24" stroke-width="4" stroke-linejoin="round" stroke-linecap="round">
        <circle cx="32" cy="32" r="28"/>
        <path d="M32 12v40"/>
        <path d="M12 32h40"/>
      </svg>
      Football Challenge
    </div>
    <div class="game-card" id="card-racing" tabindex="0" role="button" aria-pressed="false" aria-label="Play Car Racing Game">
      <svg viewBox="0 0 64 64" fill="none" stroke="#f9ca24" stroke-width="4" stroke-linejoin="round" stroke-linecap="round">
        <rect x="14" y="24" width="36" height="16" rx="3" ry="3"/>
        <circle cx="20" cy="44" r="6"/>
        <circle cx="44" cy="44" r="6"/>
      </svg>
      Car Racing
    </div>
  </section>

  <!-- Games Sections -->
  <section id="game-chess" class="game-container" aria-hidden="true" tabindex="-1">
    <h2 class="game-title">3D Chess</h2>
    <canvas id="chess-canvas" width="800" height="480" aria-label="3D chess game"></canvas>
    <div class="controls">
      <button class="btn-control" id="chess-start">Start Game</button>
      <button class="btn-control" id="chess-pause">Pause</button>
      <button class="btn-control" id="chess-reset">Reset</button>
    </div>
    <div class="scoreboard" id="chess-score">Score: 0</div>
  </section>

  <section id="game-football" class="game-container" aria-hidden="true" tabindex="-1">
    <h2 class="game-title">Football Challenge</h2>
    <canvas id="football-canvas" width="800" height="480" aria-label="Football game"></canvas>
    <div class="controls">
      <button class="btn-control" id="football-start">Start Game</button>
      <button class="btn-control" id="football-pause">Pause</button>
      <button class="btn-control" id="football-reset">Reset</button>
    </div>
    <div class="scoreboard" id="football-score">Score: 0</div>
  </section>

  <section id="game-racing" class="game-container" aria-hidden="true" tabindex="-1">
    <h2 class="game-title">Car Racing</h2>
    <canvas id="racing-canvas" width="800" height="480" aria-label="Car racing game"></canvas>
    <div class="controls">
      <button class="btn-control" id="racing-start">
        Start Game</button>
      <button class="btn-control" id="racing-pause">Pause</button>
      <button class="btn-control" id="racing-reset">Reset</button>
    </div>
    <div class="scoreboard" id="racing-score">Score: 0</div>
  </section>
</main>

<footer>
  &copy; 2025 Legon TV | All rights reserved.
  <div class="footer-links">
    <a href="https://www.tiktok.com/@legon.tvv" target="_blank" rel="noopener noreferrer">TikTok</a>
    <a href="https://www.instagram.com/legontv.web" target="_blank" rel="noopener noreferrer">Instagram</a>
    <a href="https://www.youtube.com/@legontv" target="_blank" rel="noopener noreferrer">YouTube</a>
  </div>
</footer>

<script>
(() => {
  // Utility to show/hide game sections
  const gameCards = document.querySelectorAll('.game-card');
  const gameContainers = {
    chess: document.getElementById('game-chess'),
    football: document.getElementById('game-football'),
    racing: document.getElementById('game-racing')
  };

  // Hide all games except selected
  function showGame(name) {
    Object.entries(gameContainers).forEach(([key, el]) => {
      if (key === name) {
        el.classList.add('active');
        el.setAttribute('aria-hidden', 'false');
        el.focus();
      } else {
        el.classList.remove('active');
        el.setAttribute('aria-hidden', 'true');
      }
    });
  }

  // Add click + keyboard accessibility on cards
  gameCards.forEach(card => {
    card.addEventListener('click', () => {
      const id = card.id;
      if (id === 'card-chess') showGame('chess');
      else if (id === 'card-football') showGame('football');
      else if (id === 'card-racing') showGame('racing');
    });
    card.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        card.click();
      }
    });
  });

  // ============ 3D Chess Game =============
  class Chess3D {
    constructor(canvas, scoreDisplay) {
      this.canvas = canvas;
      this.scoreDisplay = scoreDisplay;
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(45, canvas.width / canvas.height, 0.1, 1000);
      this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      this.renderer.setSize(canvas.width, canvas.height);
      this.renderer.setClearColor(0x0a2a5a, 1);

      // Controls for orbit
      this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      this.controls.enableDamping = true;
      this.controls.dampingFactor = 0.1;
      this.controls.minDistance = 10;
      this.controls.maxDistance = 60;
      this.controls.maxPolarAngle = Math.PI / 2.3;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      this.scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(10, 20, 10);
      this.scene.add(dirLight);

      this.camera.position.set(30, 30, 30);
      this.controls.update();

      // Game state
      this.boardGroup = new THREE.Group();
      this.scene.add(this.boardGroup);
      this.piecesGroup = new THREE.Group();
      this.scene.add(this.piecesGroup);

      this.isRunning = false;
      this.score = 0;

      this.raycaster = new THREE.Raycaster();
      this.mouse = new THREE.Vector2();
      this.selectedPiece = null;
      this.possibleMoves = [];

      this._initBoard();
      this._initPieces();

      this._animate = this._animate.bind(this);

      this._bindEvents();
    }

    _initBoard() {
      // Create chessboard 8x8 squares alternating colors
      const squareSize = 3;
      const darkColor = 0x223344;
      const lightColor = 0xcfcfcf;

      for (let x = 0; x < 8; x++) {
        for (let z = 0; z < 8; z++) {
          const geometry = new THREE.BoxGeometry(squareSize, 0.3, squareSize);
          const color = (x + z) % 2 === 0 ? lightColor : darkColor;
          const material = new THREE.MeshPhongMaterial({ color });
          const square = new THREE.Mesh(geometry, material);
          square.position.set(
            (x - 3.5) * squareSize,
            0,
            (z - 3.5) * squareSize
          );
          this.boardGroup.add(square);
        }
      }
    }

    _initPieces() {
      // We'll create simple geometric shapes for pieces with colors
      // White pieces on one side, black pieces on other
      this.pieces = [];
      this.piecesGroup.clear?.();
      this.piecesGroup = new THREE.Group();
      this.scene.add(this.piecesGroup);

      // Piece shapes:
      // Pawn: small cylinder
      // Rook: cube
      // Knight: cone
      // Bishop: sphere
      // Queen: torus
      // King: cylinder with sphere top

      const pieceSize = 1.2;
      const whiteMaterial = new THREE.MeshPhongMaterial({ color: 0xf0e68c });
      const blackMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

      const positions = {
        pawns: [...Array(8).keys()].map(i => [i, 1]),
        rooks: [[0,0],[7,0]],
        knights: [[1,0],[6,0]],
        bishops: [[2,0],[5,0]],
        queen: [[3,0]],
        king: [[4,0]],
      };

      // White side
      // Pawns
      positions.pawns.forEach(([x,z]) => {
        this._addPiece('pawn', x, z, whiteMaterial, true);
      });
      // Rooks
      positions.rooks.forEach(([x,z]) => this._addPiece('rook', x, z, whiteMaterial, true));
      // Knights
      positions.knights.forEach(([x,z]) => this._addPiece('knight', x, z, whiteMaterial, true));
      // Bishops
      positions.bishops.forEach(([x,z]) => this._addPiece('bishop', x, z, whiteMaterial, true));
      // Queen
      positions.queen.forEach(([x,z]) => this._addPiece('queen', x, z, whiteMaterial, true));
      // King
      positions.king.forEach(([x,z]) => this._addPiece('king', x, z, whiteMaterial, true));

      // Black side (mirrored on z axis)
      const mirrorZ = (z) => 7 - z;
      // Pawns
      positions.pawns.forEach(([x,z]) => {
        this._addPiece('pawn', x, mirrorZ(z), blackMaterial, false);
      });
      // Rooks
      positions.rooks.forEach(([x,z]) => this._addPiece('rook', x, mirrorZ(z), blackMaterial, false));
      // Knights
      positions.knights.forEach(([x,z]) => this._addPiece('knight', x, mirrorZ(z), blackMaterial, false));
      // Bishops
      positions.bishops.forEach(([x,z]) => this._addPiece('bishop', x, mirrorZ(z), blackMaterial, false));
      // Queen
      positions.queen.forEach(([x,z]) => this._addPiece('queen', x, mirrorZ(z), blackMaterial, false));
      // King
      positions.king.forEach(([x,z]) => this._addPiece('king', x, mirrorZ(z), blackMaterial, false));
    }

    _addPiece(type, x, z, material, isWhite) {
      let geometry;
      const size = 1.2;
      switch(type) {
        case 'pawn':
          geometry = new THREE.CylinderGeometry(size/4, size/4, size*1.5, 20);
          break;
        case 'rook':
          geometry = new THREE.BoxGeometry(size*0.8, size*1.5, size*0.8);
          break;
        case 'knight':
          geometry = new THREE.ConeGeometry(size/1.5, size*1.5, 20);
          break;
        case 'bishop':
          geometry = new THREE.SphereGeometry(size/1.5, 32, 16);
          break;
        case 'queen':
          geometry = new THREE.TorusGeometry(size/1.3, size/5, 16, 100);
          break;
        case 'king':
          geometry = new THREE.CylinderGeometry(size/3, size/3, size*2, 20);
          break;
      }
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(
        (x - 3.5) * 3,
        0.8,
        (z - 3.5) * 3
      );
      mesh.userData = { type, x, z, isWhite };
      this.piecesGroup.add(mesh);
      this.pieces.push(mesh);
    }

    _bindEvents() {
      this.canvas.addEventListener('pointerdown', this._onPointerDown.bind(this));
    }

    _onPointerDown(event) {
      if (!this.isRunning) return;

      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      this.raycaster.setFromCamera(this.mouse, this.camera);

      // Intersect pieces first
      const intersectsPieces = this.raycaster.intersectObjects(this.pieces, true);

      if (intersectsPieces.length > 0) {
        const picked = intersectsPieces[0].object;
        if (this.selectedPiece === picked) {
          // Deselect
          this._clearSelection();
        } else {
          this._selectPiece(picked);
        }
      } else if (this.selectedPiece) {
        // If a piece is selected, check board squares for move

        // Intersect board squares
        const squares = this.boardGroup.children;
        const intersectsSquares = this.raycaster.intersectObjects(squares);

        if (intersectsSquares.length > 0) {
          const square = intersectsSquares[0].object;
          const pos = square.position;

          // Snap move logic: move selected piece here if valid
          // For demo, allow any move - advanced chess logic omitted for brevity
          this.selectedPiece.position.set(pos.x, this.selectedPiece.position.y, pos.z);
          this.selectedPiece.userData.x = Math.round(pos.x / 3 + 3.5);
          this.selectedPiece.userData.z = Math.round(pos.z / 3 + 3.5);

          this._clearSelection();
          this.score += 10;
          this._updateScore();
        }
      }
    }

    _selectPiece(piece) {
      this._clearSelection();
      this.selectedPiece = piece;
      piece.material.emissive = new THREE.Color(0xf9ca24);
      piece.material.emissiveIntensity = 0.6;
    }

    _clearSelection() {
      if (this.selectedPiece) {
        this.selectedPiece.material.emissiveIntensity = 0;
        this.selectedPiece = null;
      }
    }

    _updateScore() {
      this.scoreDisplay.textContent = `Score: ${this.score}`;
    }

    start() {
      if (this.isRunning) return;
      this.isRunning = true;
      this.score = 0;
      this._updateScore();
      this._animate();
    }

    pause() {
      this.isRunning = false;
    }

    reset() {
      this.isRunning = false;
      this.score = 0;
      this._updateScore();
      this.pieces.forEach(p => this.piecesGroup.remove(p));
      this._initPieces();
    }

    _animate() {
      if (!this.isRunning) return;
      requestAnimationFrame(this._animate);
      this.controls.update();
      this.renderer.render(this.scene, this.camera);
    }
  }

  // ============ Football Game =============
  class FootballGame {
    constructor(canvas, scoreDisplay) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.scoreDisplay = scoreDisplay;
      this.width = canvas.width;
      this.height = canvas.height;

      // Game elements
      this.goal = { x: this.width / 2 - this.goalWidth / 2, y: 0, width: this.goalWidth, height: this.goalHeight };
      this.score = 0;
      this.isRunning = false;

      this._bindEvents();
    }

    _bindEvents() {
      this.canvas.addEventListener('click', (e) => {
        if (!this.isRunning) return;
        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        const dx = clickX - this.ball.x;
        const dy = clickY - this.ball.y;
        const magnitude = Math.sqrt(dx * dx + dy * dy);
        this.ball.vx = (dx / magnitude) * 5;
        this.ball.vy = (dy / magnitude) * 5;
      });
    }

    _updateScore() {
      this.scoreDisplay.textContent = `Score: ${this.score}`;
    }

    _drawField() {
      const ctx = this.ctx;
      ctx.fillStyle = "#4CAF50";
      ctx.fillRect(0, 0, this.width, this.height);

      // Draw goals
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(this.goal.x, this.goal.y, this.goal.width, this.goal.height);
    }

    _drawBall() {
      const ctx = this.ctx;
      ctx.beginPath();
      ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.closePath();
    }

    _update() {
      this.ball.x += this.ball.vx;
      this.ball.y += this.ball.vy;

      // Bounce off walls
      if (this.ball.x < this.ball.radius || this.ball.x > this.width - this.ball.radius) {
        this.ball.vx *= -1;
      }
      if (this.ball.y < this.ball.radius || this.ball.y > this.height - this.ball.radius) {
        this.ball.vy *= -1;
      }

      // Goal detection
      if (
        this.ball.y - this.ball.radius <= this.goal.y + this.goal.height &&
        this.ball.x >= this.goal.x &&
        this.ball.x <= this.goal.x + this.goal.width
      ) {
        this.score += 1;
        this._updateScore();
        this.ball.x = this.width / 2;
        this.ball.y = this.height / 2;
        this.ball.vx = 5;
        this.ball.vy = 3;
      }
    }

    _draw() {
      this._drawField();
      this._drawBall();
    }

    _loop = () => {
      if (!this.isRunning) return;
      this._update();
      this._draw();
      requestAnimationFrame(this._loop);
    }

    start() {
      this.isRunning = true;
      this.score = 0;
      this._updateScore();
      this._loop();
    }

    pause() {
      this.isRunning = false;
    }

    reset() {
      this.pause();
      this.ball = { x: this.width / 2, y: this.height / 2, radius: 15, vx: 5, vy: 3 };
      this.score = 0;
      this._updateScore();
      this._draw();
    }
  }

  // ============ Racing Game =============
  class RacingGame {
    constructor(canvas, scoreDisplay) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.scoreDisplay = scoreDisplay;
      this.width = canvas.width;
      this.height = canvas.height;
      this.car = { x: this.width / 2, y: this.height - 60, width: 40, height: 70, speed: 5 };
      this.obstacles = [];
      this.score = 0;
      this.isRunning = false;

      this._bindEvents();
    }

    _bindEvents() {
      window.addEventListener('keydown', (e) => {
        if (!this.isRunning) return;
        if (e.key === "ArrowLeft") this.car.x -= this.car.speed;
        if (e.key === "ArrowRight") this.car.x += this.car.speed;
      });
    }

    _updateScore() {
      this.scoreDisplay.textContent = `Score: ${this.score}`;
    }

    _drawRoad() {
      const ctx = this.ctx;
      ctx.fillStyle = "#333";
      ctx.fillRect(0, 0, this.width, this.height);

      ctx.strokeStyle = "#fff";
      for (let i = 0; i < this.height; i += 40) {
        ctx.beginPath();
        ctx.moveTo(this.width / 2 - 2, i);
        ctx.lineTo(this.width / 2 - 2, i + 20);
        ctx.stroke();
      }
    }

    _drawCar() {
      const ctx = this.ctx;
      ctx.fillStyle = "#00f";
      ctx.fillRect(this.car.x, this.car.y, this.car.width, this.car.height);
    }

    _drawObstacles() {
      const ctx = this.ctx;
      ctx.fillStyle = "#f00";
      this.obstacles.forEach(ob => {
        ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
      });
    }

    _update() {
      // Move obstacles
      this.obstacles.forEach(ob => ob.y += 5);
      // Remove off-screen
      this.obstacles = this.obstacles.filter(ob => ob.y < this.height);

      // Add new obstacles
      if (Math.random() < 0.05) {
        const x = Math.random() * (this.width - 50);
        this.obstacles.push({ x, y: -60, width: 40, height: 60 });
      }

      // Collision detection
      for (const ob of this.obstacles) {
        if (
          this.car.x < ob.x + ob.width &&
          this.car.x + this.car.width > ob.x &&
          this.car.y < ob.y + ob.height &&
          this.car.y + this.car.height > ob.y
        ) {
          this.pause();
          alert("Crash! Game Over.");
          return;
        }
      }

      this.score += 1;
      this._updateScore();
    }

    _draw() {
      this._drawRoad();
      this._drawCar();
      this._drawObstacles();
    }

    _loop = () => {
      if (!this.isRunning) return;
      this._update();
      this._draw();
      requestAnimationFrame(this._loop);
    }

    start() {
      this.isRunning = true;
      this.score = 0;
      this._updateScore();
      this._loop();
    }

    pause() {
      this.isRunning = false;
    }

    reset() {
      this.pause();
      this.car.x = this.width / 2;
      this.obstacles = [];
      this.score = 0;
      this._updateScore();
      this._draw();
    }
  }

  // Game init
  const chessGame = new Chess3D(document.getElementById('chess-canvas'), document.getElementById('chess-score'));
  const footballGame = new FootballGame(document.getElementById('football-canvas'), document.getElementById('football-score'));
  const racingGame = new RacingGame(document.getElementById('racing-canvas'), document.getElementById('racing-score'));

  document.getElementById('chess-start').onclick = () => chessGame.start();
  document.getElementById('chess-pause').onclick = () => chessGame.pause();
  document.getElementById('chess-reset').onclick = () => chessGame.reset();

  document.getElementById('football-start').onclick = () => footballGame.start();
  document.getElementById('football-pause').onclick = () => footballGame.pause();
  document.getElementById('football-reset').onclick = () => footballGame.reset();

  document.getElementById('racing-start').onclick = () => racingGame.start();
  document.getElementById('racing-pause').onclick = () => racingGame.pause();
  document.getElementById('racing-reset').onclick = () => racingGame.reset();
})();
</script>
</body>
</html>
